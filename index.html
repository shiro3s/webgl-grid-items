<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

<!-- <!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Image Grid</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 14px;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">マウスをドラッグしてカメラを操作</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        window.onload = function() {
            // シーン、カメラ、レンダラーの設定
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            
            // レンダラーのサイズをウィンドウサイズに合わせる
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // カメラの初期位置を正面に設定
            camera.position.set(0, 0, 100);
            camera.lookAt(0, 0, 0);

            // 照明の追加
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // 画像のロード
            const textureLoader = new THREE.TextureLoader();
            const images = [];
            for (let i = 1; i <= 40; i++) {
                // プレースホルダー画像を使用して、ユーザー環境で動くように設定
                images.push(`./assets/${i}.webp`);
            }
            
            // グリッドの作成
            const rows = 7;
            const cols = 7;
            const tileSize = 50;
            const spacing = tileSize + 10; // タイルサイズに10pxの余白を追加
            
            const meshes = [];

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const randomImage = images[Math.floor(Math.random() * images.length)];
                    textureLoader.load(randomImage, (texture) => {
                        const geometry = new THREE.PlaneGeometry(tileSize, tileSize);
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                        const mesh = new THREE.Mesh(geometry, material);

                        mesh.position.x = (j - (cols - 1) / 2) * spacing;
                        mesh.position.y = (i - (rows - 1) / 2) * spacing;

                        scene.add(mesh);
                        meshes.push({
                            mesh: mesh,
                            colIndex: j
                        });
                    }, undefined, (err) => {
                        console.error('An error happened while loading texture:', err);
                    });
                }
            }

            // マウスインタラクション
            let isDragging = false;
            let previousMousePosition = {
                x: 0,
                y: 0
            };

            function toRadians(angle) {
                return angle * (Math.PI / 180);
            }

            function onMouseDown(event) {
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }

            function onMouseUp(event) {
                isDragging = false;
            }

            function onMouseMove(event) {
                if (!isDragging) return;

                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                // カメラの回転
                const sensitivity = 0.2;
                const rotationX = toRadians(deltaY * sensitivity);
                const rotationY = toRadians(deltaX * sensitivity);

                const cameraMatrix = new THREE.Matrix4();
                cameraMatrix.extractRotation(camera.matrixWorld);

                const cameraUp = new THREE.Vector3(0, 1, 0);
                const cameraRight = new THREE.Vector3(1, 0, 0);
                cameraUp.transformDirection(cameraMatrix);
                cameraRight.transformDirection(cameraMatrix);

                const quaternionX = new THREE.Quaternion().setFromAxisAngle(cameraRight, -rotationX);
                const quaternionY = new THREE.Quaternion().setFromAxisAngle(cameraUp, -rotationY);
                const finalQuaternion = new THREE.Quaternion().multiplyQuaternions(quaternionY, quaternionX);

                camera.position.applyQuaternion(finalQuaternion);
                camera.up.applyQuaternion(finalQuaternion);
                camera.lookAt(0, 0, 0);

                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }

            function onMouseWheel(event) {
                const fov = camera.fov + event.deltaY * 0.05;
                camera.fov = THREE.MathUtils.clamp(fov, 10, 100);
                camera.updateProjectionMatrix();
            }

            // イベントリスナーの追加
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', onMouseWheel, false);
            
            // ウィンドウのリサイズ
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }, false);
            
            // アニメーションループ
            function animate() {
                requestAnimationFrame(animate);

                // メッシュを列ごとに移動させる
                meshes.forEach(meshObject => {
                    const mesh = meshObject.mesh;
                    const colIndex = meshObject.colIndex;
                    
                    // 奇数列 (0, 2, 4, 6) は上、偶数列 (1, 3, 5) は下に移動
                    if (colIndex % 2 !== 0) { // 奇数列
                        mesh.position.y += 0.5;
                        // 画面上に出たら下に戻す
                        if (mesh.position.y > (rows / 2) * spacing) {
                            mesh.position.y -= rows * spacing;
                        }
                    } else { // 偶数列
                        mesh.position.y -= 0.5;
                        // 画面下に出たら上に戻す
                        if (mesh.position.y < -(rows / 2) * spacing) {
                            mesh.position.y += rows * spacing;
                        }
                    }
                });

                renderer.render(scene, camera);
            }

            animate();
        };
    </script>
</body>
</html> -->

<!-- <!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Image Grid</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 14px;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">マウスをドラッグして画像をスクロール</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        window.onload = function() {
            // シーン、カメラ、レンダラーの設定
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            
            // レンダラーのサイズをウィンドウサイズに合わせる
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // カメラの初期位置を正面に設定
            camera.position.set(0, 0, 100);
            camera.lookAt(0, 0, 0);

            // 照明の追加
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // 画像のロード
            const textureLoader = new THREE.TextureLoader();
            const images = [];
            for (let i = 1; i <= 40; i++) {
                // プレースホルダー画像を使用して、ユーザー環境で動くように設定
                images.push(`./assets/${i}.webp`);
            }
            
            // グリッドの作成
            const rows = 7;
            const cols = 7;
            const tileSize = 50;
            const spacing = tileSize + 10; // タイルサイズに10pxの余白を追加
            
            const meshes = [];

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const randomImage = images[Math.floor(Math.random() * images.length)];
                    textureLoader.load(randomImage, (texture) => {
                        const geometry = new THREE.PlaneGeometry(tileSize, tileSize);
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                        const mesh = new THREE.Mesh(geometry, material);

                        mesh.position.x = (j - (cols - 1) / 2) * spacing;
                        mesh.position.y = (i - (rows - 1) / 2) * spacing;

                        scene.add(mesh);
                        meshes.push({
                            mesh: mesh,
                            colIndex: j
                        });
                    }, undefined, (err) => {
                        console.error('An error happened while loading texture:', err);
                    });
                }
            }

            // マウスインタラクションとスクロールロジック
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            const dragSpeed = 0.5;
            const wheelSpeed = 0.5;

            function onMouseDown(event) {
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }

            function onMouseUp() {
                isDragging = false;
            }

            function onMouseMove(event) {
                if (!isDragging) return;

                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                // メッシュを移動させる
                meshes.forEach(meshObject => {
                    const mesh = meshObject.mesh;
                    mesh.position.x += deltaX * dragSpeed;
                    mesh.position.y -= deltaY * dragSpeed;
                });

                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }

            function onMouseWheel(event) {
              meshes.forEach((meshObject) => {
                const mesh = meshObject.mesh;
                mesh.position.x -= event.deltaX * wheelSpeed;
                mesh.position.y = event.deltaY * wheelSpeed
              })
            }

            // イベントリスナーの追加
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', onMouseWheel, false);
            
            // ウィンドウのリサイズ
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }, false);
            
            // アニメーションループ
            function animate() {
                requestAnimationFrame(animate);

                // 無限スクロールのロジックを適用
                meshes.forEach(meshObject => {
                    const mesh = meshObject.mesh;
                    
                    const minX = -(cols / 2) * spacing;
                    const maxX = (cols / 2) * spacing;
                    const minY = -(rows / 2) * spacing;
                    const maxY = (rows / 2) * spacing;

                    // X方向の無限スクロール
                    if (mesh.position.x > maxX) {
                        mesh.position.x -= cols * spacing;
                    } else if (mesh.position.x < minX) {
                        mesh.position.x += cols * spacing;
                    }

                    // Y方向の無限スクロール
                    if (mesh.position.y > maxY) {
                        mesh.position.y -= rows * spacing;
                    } else if (mesh.position.y < minY) {
                        mesh.position.y += rows * spacing;
                    }
                });

                renderer.render(scene, camera);
            }

            animate();
        };
    </script>
</body>
</html> -->
